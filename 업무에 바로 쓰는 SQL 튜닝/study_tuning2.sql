/*---------- 처음부터 모든 데이터를 가져오는 나쁜 SQL문 ----------*/ 
 /*튜닝 Before*/
 /*desc: id가 1인 두개행에 먼저 접근하여 중첩 루프 조인을 하는 두 개테이블은 사원 테이블과 <derived2>라는 테이블로
 먼저 출력된 사원 테이블이 드라이빙 테이블이고 나중에 출력된 <derived2> 테이블이 드리븐 테이블이다.
 <derived2> 테이블은 id가 2이고 select_type 항목이 DERIVED러 작성된 세번째 행의 인라인 뷰를 가리키는 것으로 FROM 절에서 급여테이블로 수행한
 그루핑 결과를 새로생성한 임시 테이블의 메모리나 디스크에 올려놓는다.
 즉 3번째행이 인라인뷰에 그루핑때문에 새로 생성한 임시테이블이라는 것이다.
급여 테이블 인라인뷰가 실행이되지만 거의 모든 데이터를 그루핑을 한다 그 이후에 조인을하기에 전체 테이블을 조인하는것이므로 효율이 안좋다.
하지만 BETWEEN 구믄으로 추출하는 데이터는 100건 뿐이기에 between 구문을 중심으로 실행하는 쪽으로 튜닝을 고민해봐야한다.*/

EXPLAIN SELECT 사원.`사원번호`,
	급여.평균연봉,
	급여.최고연봉,
	급여.최저연봉
FROM 사원, ( 
		SELECT 사원번호, ROUND(AVG(연봉),0) 평균연봉, ROUND(MAX(연봉),0) 최고연봉, ROUND(MIN(연봉), 0) 최저연봉
		FROM 급여
		GROUP BY 사원번호
	) 급여
WHERE 사원.`사원번호` = 급여.`사원번호`
AND 사원.`사원번호` BETWEEN 10001 AND 10100;
 
/*튜닝 After*/
/*desc: where 절의 between 구문으로 100건의 데이터만 가져온다. 전체 사원데이터가 아닌 필요한 사원 정보에만 접근 후
급여 테이블에서 각 사원번호별 평균연봉, 최고연봉, 최저연봉을 구한다.
하지만 해당쿼리는 스칼라서브쿼리로 급여 테이블에 3번이나 접근하지만 WHERE 절에서 추출하려는 사원 테이블의 데이터가
사원 테이블의 전테 데이터 대비 극히 소량(0.0003%)에 불과하므로 인덱스를 활용해서 수행하는 3번의 스칼라 서브쿼리는 많은 리소스를 소모하지 않는다.
즉 각 스칼라 서브쿼리는 100건 정도가 되는 사원번호와 인덱스를 활용하면서 조인을 수행하는거다.
하지만 데이터가 많은 외부쿼리라면 호울을 반복해서 일으키므로 지양해야겠지만 위에 말했다시피 사원 테이블에 데이터가 적어
비효율적인 부분이 거의없다.*/
EXPLAIN SELECT 사원.`사원번호`,
	( SELECT ROUND(AVG(연봉), 0)
		FROM 급여 AS 급여1
		WHERE 사원번호 = 사원.`사원번호`
	) AS 평균연봉,
	( SELECT ROUND(MAX(연봉), 0)
		FROM 급여 AS 급여2
		WHERE 사원번호 = 사원.`사원번호`
	) AS 최고연봉,
	( SELECT ROUND(MIN(연봉), 0)
		FROM 급여 AS 급여3
		WHERE 사원번호 = 사원.`사원번호`
	) AS 최저연봉
FROM 사원
WHERE 사원.`사원번호` BETWEEN 10001 AND 10100;

/*---------- 비효율적인 페이징을 수행하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 먼저 id가 1인 두개행이 출력이되며 드라이빙 테이블은 사원과  드리븐 테이블은 급여 테이블을 조인을 수행한다.
사원테이블과 급여테이블은 각각 기본키로 데이터를 접근하며 이 때 드라이빙 테이블인 사원 테이블은 그루핑과 정렬연산을 위해 임시테이블을
생성한뒤 정렬작업을 수행한다. LIMIT 연산으로 10건의 데이터를 가져오기 위해 수십만건의 데이터를 대상으로 조인을 수행한 뒤
그루핑과 정렬작업을 수행한다. 하지만 전체 데이터를 가져 온뒤 마지막으로 10건의 데이터만 조회하는게 과연 효율적인 방법인지 고민해봐야한다.*/
EXPLAIN SELECT 사원.사원번호, 사원.이름, 사원.성, 사원.`입사일자`
FROM 사원, 급여
WHERE 사원.사원번호 = 급여.`사원번호`
AND 사원.사원번호 BETWEEN 10001 AND 50000
GROUP BY 사원.사원번호
ORDER BY SUM(급여.연봉) DESC
LIMIT 150,10;

/*튜닝 After*/
/*desc: 급여 테이블에서는 GROUP BY 절을 통한 구르핑과 ORDER BY절을 통한 정렬작업을 FROM 절의 인라인 뷰로 작성했다.
인라인 뷰에 데이터 건수만큼 LIMIT 절로 제약을 설정하여 사원 테이블과 조인할 수 있는 데이터 건수를 줄일 수 있다.
즉 튜닝전에는 전체테이블 조인하고 LIMIT 절이 실행되었지만 해당 쿼리는 인라인뷰 작성으로 전체의 급여 테이블이 아닌 10건의 급여테이블로 조인을 수행하므로 매울 효율적이다.
정리를 하자면 우선 id가 1인 <derived2> 테이블과 사원 테이블 대상으로 중첩 루프 조인을 수행한다. 이때 드라이빙 테이블인 <derived2> 테이블은
id가 2에 해당하는 급여 테이블이며 드리븐 테이블은 사원 테이블이다. <derived2> 테이블은 WHERE 절의 사원번호 BETWEEN 10001 AND 50000 조건절에 따라 범위 스캔을 수행하는 인라인 뷰이며
스토리지 엔진에서 가져온 임시 테이블에 상주시켜 정렬작업을 수행한다. 인라인뷰인 급여 테이블 기준으로 사원 테이블에 반복해 접근하고
WHERE 절의 사원.사원번호 = 급여.사원번호 조건절로 조인을 수행한다. 이때 드라이빙 테이블은 테이블 풀 스캔을 한다. 드리븐 테이블은 기본키를 활용하여 데이터를 추출하며
기본키를 매번 가져오므로 rows 항목에는 1개 데이터에만 접근한것으로 출력된다.*/
/*info: <derived2> 테이블은 id가 2인 테이블에 파생된 임시테이블이다 즉 2번이 먼저 실행이되고 <derived2>라는 임시테이블이 생성이되어 사원테이블과 조인을 수행한것이다.*/
EXPLAIN SELECT 사원.사원번호, 사원.이름, 사원.성, 사원.입사일자
FROM (
	SELECT 사원번호 FROM 급여
	WHERE 사원번호 BETWEEN 10001 AND 50000
	GROUP BY 사원번호
	ORDER BY SUM(급여.연봉) DESC
	LIMIT 150, 10
     )	급여, 사원
WHERE 사원.사원번호 = 급여.사원번호;

/*---------- 필요이상으로 많은 정보를 가져오는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: id가 1인행만 있으므로 먼저 출려된 사원 테이블이 데이터에 접근하는 드라이빙 테이블이고 나중에 출력된 부서관리자 테이블이 드리븐테이블임을 알 수 있다.
사원 테이블은 사원번호>300000 조건 때문에 범위스캔을 수행하며 기본키를 활용해 데이터에 접근한것을 알 수 있다. 또한 부서관리자 테이블은 사원.사원번호 = 관리자.사원번호
의 외부조인에 따라 기본 키를 활용하여 중첩루프조인할 때 마다 1건의 데이터에 접근하는 걸 확인 할 수 있다. 
하지만 여기서 사원테이블의 사원번호 데이터 건수를 집계하에 부서관리자 테이블과 외부조인이 꼭 필요한지 고민을 해봐야한다.*/
EXPLAIN SELECT COUNT(사원번호) AS 카운트
FROM (
	SELECT 사원.`사원번호`, 부서관리자.`부서번호`
	FROM ( SELECT * FROM 사원 WHERE 성별 = 'M'
		AND 사원번호 > 300000
	) 사원
LEFT JOIN 부서관리자
ON 사원.`사원번호` = 부서관리자.`사원번호`
) 서브쿼리;

/*튜닝 After*/
/*desc: 사원번호의 건수를 구하는 과정에서 부서관리자 테이블은 필요하지 않는다. 외부조인의 경우
드리븐 테이블인 부서관리자 테이블은 있어도되고 없어도되는 역할을 수행하기 때문이다. 따라서 부서관리자 테이블과의 조인 부분을 제거되고 
외부조인을 이용한 데이터 접근이 불필요하므로 사원 테이블의 rows 15만건이었던거에 비해 5만 건의 데이터에만 접근함을 알 수 있다.*/
EXPLAIN SELECT COUNT(사원번호) AS 카운트
FROM 사원 
WHERE 성별 = 'M'
AND 사원번호 > 300000;
		
/*---------- 대량의 데이터를 가져와 조인하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 여기서 관리자 테이블은 index 풀스캔 방식으로 데이터를 접근한다.
인덱스 풀스캔 방식은 관리자 테이블의 데이터 접근을 구체화할 수 있는 조건문이 없으므로 I_부서번호 인덱스로 처음부터 끝까지 전체 인덱스를 스캔한다.
드리븐 테이블인 매핑 테이블은 관리자.부서번호 = 매핑.부서번호 조건절로 데이터에 접근하고 이 때 증복을 제거하는 DISTINCT 연산도 수행한다.
조인을 수행하는 부서번호 열이 부서관리자 테이블과 부서사원_매핑 테이블에 모두 있으므로 select 절을 매핑.부서번호 또는 관리자.부서번호로
작성해도 모두 동일한 결과를 출력하게 된다. 그렇다면 두 테이블 모두 데이터에 접근한 뒤 부서번호가 같은지 일일 확인하는 과연 필요한지 의문이 생긴다.
그저 둘중 하나의 테이블은 단순히 부서번호가 존재하는지 여부만판단해도 충분하지 않은가라는 의문이 생긴다.
또한 FROm 절과 WHERE 절로 조인을 수행한 뒤 그 조인결과에서 DISTINC 작업을 수행한다.
하지만 이렇게 수십만 개의 데이터를 조인하기 전에 미리 중복을 제거를 할 수는 없을지 고민해봐야한다.*/
/*info: 조인 수행 => 중복제거(DISTINCT)*/
EXPLAIN SELECT DISTINCT 매핑.부서번호 FROM 부서관리자 관리자, 부서사원_매핑 매핑
WHERE 관리자.`부서번호` = 매핑.`부서번호` 
ORDER BY 매핑.`부서번호`;

SELECT COUNT(*) FROM 부서관리자;
SELECT COUNT(*) FROM 부서사원_매핑;

/*튜닝 After*/
/*desc: 부서사원_매핑 테이블의 데이터를 가져올 때 부서번호 데이터를 미리 중복제거를 한다.
가벼워진 부서사원_매핑 테이블의 데이터에 대해 부서관리자 테이블은 같은 부서번호 데이터가 있는지 여부만 판단한다.
부서관리자 테이블의 데이터를 모두 확인하지 않고도 동일한 부서번호가 있다면 이후의 데이터에는 더 접근하지 않는 EXISTS 연산자를 활용한다.
즉 중복제거를 미리 수행하고 SELECT 절에서 활용하지 않는 부서관리자 데이터는 존재여부만 판단하는 방식으로 튜닝한것이다.
<derived2> 테이블은 id가 2인 행의 인라인 뷰로 FROM절에 중복제거 작업까지 마친 매핑 테이블이다. 
DISTINCT 작업을 수행하고자 I_부서번호 인덱스로 정렬한 뒤 중복을 제거하겠다는 의미로 Extra 항목에 Using index for group-by가 표시된다.
즉 드라이빙 테이블인 <subquery3>는 id가 3인 관리자 테이블로서 전체 24 개 데이터를 인덱스로 풀스캔으로 수행 한뒤에 드리븐 테이블인 중복 제거된 <subquery3> 테이블과 조인
이때 부서관리자 테이블에 EXISTS 연산자로 비교할 부서번호가 있다면 이후로 동일한 부서번호 데이터는 확인하지 않고 건더 뛴다.*/
/*info: id 2번이 실행되면서 파생테이블인 <derived2> 라는 임시 테이블을 생성하고 그 후 id 3번이 실행되면서 <subquery3>라는 임시 테이블이 생성됐다
이 때 <subquery3>와 <derived2> 테이블의 id 가 같으므로 둘이 조인을 하는거를 알 수 있다. 이 때 <subquery3>는 드라이빙 <derived2>는 드리븐 테이블이다.*/
EXPLAIN SELECT 매핑.부서번호 FROM (SELECT DISTINCT 부서번호 FROM 부서사원_매핑 매핑) 매핑
WHERE EXISTS ( SELECT 1 FROM 부서관리자 관리자 WHERE 부서번호 = 매핑.부서번호)
ORDER BY 매핑.부서번호;

/*---------- 인덱스 없이 작은 규모의 데이터를 조회하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 사원 테이블을 테이블 풀스캔하여 데이터를 가져옴, 스토리지엔진에서 가져온 전체 데이터 중
WHERE 이름 = "Georgi" AND 성 = "Wielonsky" 조건절로 필요한 데이터를 추출(Extra: Using Where)하여 출력 즉 필터조건을 사용했다는 뜻
단 1건의 데이터를 가져오고자 테이블을 처음부터 끝까지 스캔하는 방식은 비효율적이다. 조건절에 해당하는 열들이 자주 호출된다면, 인덱스로
빠른 데이터 접근을 유도하는 방식으로 튜닝의 방향을 잡을 수 있을것이다. 우선 이름, 성 열을 대상으로 인덱스를 생성하기전에
더 다양한(많은) 값이 있는 열이 무엇인지 파악한다. 이름열은 1275개 성열의는 1637개의 값이 있으므로 데이터범위를 더 축소할 수 있는 성열을 선두 열로 삼아 인덱스를 생성한다.*/
EXPLAIN SELECT * FROM 사원 WHERE 이름 = "Georgi" AND 성 = "Wielonsky";

/*튜닝 After*/
/*desc: 생성한 I_사원_성_이름 인덱스로 인덱스 스캔을 수행 스토리지 엔젠에서 성 열과 이름 열에 조건절을 써서 데이터에 접근하므로 1건의 데이터만 최종 반환된다.*/
ALTER TABLE 사원 ADD INDEX I_사원_성_이름(성, 이름);
EXPLAIN SELECT * FROM 사원 WHERE 이름 = "Georgi" AND 성 = "Wielonsky";
/* alter table 사원 drop index I_사원_성_이름 */

/*---------- 인덱스를 하나만 사용하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 사원 테이블은 테이블 풀스캔으로 처리된다. 스토리지 엔진으로 모든 데이터를 가져온 뒤 Mysql 엔진에서 2개의 조건절을 활용하여 데이터를 필터링한다.
이름="Matt" 조건에 해당하는 데이터는 233건이고 입사일자 = '1987-03-31' 조건에 해당하는 데이터는 111건이다. 30만건에 달하는
데이터 건수와 비교했을 때 데이터 건수가 상대적으로 적다. 이처럼 소량의 데이터를 가져올 때는 테이블 풀스캔보다 인덱스 스캔이 효율적이다.
조건절 열이 포함된 인덱스를 보면 입사열자 열이 포함된_I_입사일자 인덱스는 확인되지만 이름 열이 포함된 인덱스는 없다.
이름 열에 대한 인덱스를 생성하여 각 조건절이 각각의 인덱스를 사용해 데이터에 접근할 수 있도록 튜닝 방향을 결정한다.*/
EXPLAIN SELECT * FROM 사원 WHERE 이름 = "Matt" OR 입사일자 = "1987-03-31";

/*튜닝 After*/
/*desc: 2개의 조건절 열이 가각 인덱스 스캔으로 수행되고 각결괴는 병합(index_merge)된다.
즉 이름 = "Matt" 조건절은 I_이름 인덱스를 사용하며 입사일자 = "1987-03-31" 조건절은 I_입사일자 인덱스를 사용한다.
이들 결과가 합쳐진뒤(Using union(I_이름,I_입사일자)) 최종결과를 출력한다.
info: WHERE 절 ~ OR 구무에서 한쪽의 조건절이 동등 조건이 아닌 범위조건(LIKE, BETWEEN)이라면 index_merge로 처리되지 않을 수 있다.
버전에 따라 매커니즘에 차이가 있으므로 실행계획을 확인한 뒤 UNION 이나 UNION ALL 구문등으로 분리하는걸 고려해야한다.*/
ALTER TABLE 사원 ADD INDEX I_이름(이름);
EXPLAIN SELECT * FROM 사원 WHERE 이름 = "Matt" OR 입사일자 = "1987-03-31";

/*---------- 큰 규모의 데이터 변경으로 인덱스에 영향을 주는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 튜닝전 실행계획에 따르면 기본키로 사원출입기록 테이블에 접근 한 뒤 출입문 ="B" 조건절에 행당하는 데이터만 'X'라는 출입문으로 변경한다.
UPDATE 문은 데이터수정하는 쿼리이기에 인덱스와 무관해오빌 수 있지만 그러나 UPDATE 문은 수정할 데이터에 접근한 뒤에 SET 절의 수정값으로 변경하므로,
인덱스로 데이터에 접근한다는 측면에서 인덱스의 존재 여부는 중요하다. 한편 조회한 데이터를 변경하는 범위에는 테이블뿐만 아니라 인덱스도 포함되므로 인덱스가 많은 테이블의 데이터를 변경할 떄는 성능적으로 불리하다.
인덱스를 조회해보면 SET 출입문='X'라고 되어있으므로 출입문 열을 포함하는 I_출입문 인덱스의 튜닝 여부를 고민해봐야한다.*/
/*info: mysql에서 DML(data manipulation language) 문을 수행할 때 커밋은 기본적으로 자동저장된다.
튜닝 전 SQL문은 UPDATE 문이므로 별도의 설정을 하지 않으면 바로 저장이된다. 따라서 반복되느 UPDATE 문을 수행할 때
저동저장되는 커밋 설정을, 본인이 접속한 세션에 한해서만 자동 저장되지 않도록 변경한다.
select @@autocommit; 명령문을 사용하면 autocommit 이라는 세션 기준의 시스템 변수를 확인할 수 있다. autocommit이 1이면 자동 커밋
0이면 자동커밋이 아니다. set autocommit=0; 명령문을 통해 자동 커밋되지 않도록 임의 설정한다.*/
UPDATE 사원출입기록 SET = "X" WHERE 출입문 = "B";

/*튜닝 After*/
/*desc: I_출입문 인덱스의 데이터에 매번 UPDATE 문을 수행하느라 수십초가 소요된다.
이때 사원출입기록 테이블과 같은 이력용 테이블에서는 보통 지속적인 데이터 저장만 이루어지므로 애플리케이션을 통한 I_출입문 인덱스의 활용도가 없다면 삭제하여 튜닝을 고려해볼필요가있다.
만약 업데이트 작업이 새벽 또는 서비스에 미치는 영향이 적은 시간대에 수행되는 배치성 작업이라면, 일시적으로 인덱스를 삭제한 뒤 대량 업데이트 작업을 수행하고 다시 인덱스를 생성하여
SQL 문 효율을 높일 수 있다.*/
/*info: befroe 과 after 실행계획은 똑같지만 before 같은 경우에는 데이터를 변경하는 즉시 인덱스는 재정렬하기에 내부적으로는 매우 불리하다.*/
ALTER TABLE 사원출입기록 DROP INDEX I_출입문;

/*---------- 비효율적인 인덱스를 사용하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 해당 쿼리는 I_성별_성 인덱스를 활용하여 사원 테이블에 접근한다. 성별과 성 열에 고정된 값으로 조건절(ref 항목: const, const)을 작성하여 스토리지엔진에서
인덱스 스캔으로 원하는 데이터를 가져와 출력한다. 각 조건절의 데이터를 비교해보면 성열의 데이터는 1637건, 성별 열의 데이터는 단 2건에 불과한다.
데이터 수만 놓고본다면 문제없지만 해당 인덱스는 테이블의 데이터가 늘어날경우 문제가 발생한다. 데이터가 다양하지 않은 성별 열을 선두로 구성한 인덱스가 과연 효율적인지 생각해 봐야한다.*/
/*info: 성별 데이터는 카디널리티가 낮기 때문에 데이터가 늘어날수록 랜덤액세스 빈도가 많아져 부하가생긴다.*/
EXPLAIN SELECT 사원번호, 이름, 성
FROM 사원
WHERE 성별 = 'M'
AND 성 = 'Baba';

/*튜닝 After*/
/*desc: 성별 열보다 성 열이 더 다양한 종류의 값(카디널리티가 높다)을 가지므로 성 열은 먼저 활용하면 데이터 접근 법의를 줄일 수 있다.
따라서 기존의 성별 + 성 순서로 구성된 I_성별_성 인덱스를 성+성별 순서의 I_성_성별 인덱스로 변경한다. 
그러려면 DROP INDEX로 기존 인덱스를 먼저 삭제하고 ADD INDEX로 신규 인덱스를 생성한다.
튜닝 후 실행계획은 바뀌지는 않지만 사용하는 인덱스가 달라졌고 소요시간은 줄어졌다.*/
ALTER TABLE 사원 DROP INDEX I_성별_성, ADD INDEX I_성_성별(성, 성별);

/*---------- 잘못된 열 속성으로 비효율적으로 작성한 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 첫번째 문자의 아스키 코드값이 97이고 두번째 문자의 아스키 코득밧이 99일 때만 최종 결과를 출력한다. 코드 값 97은 소문자 99는 소문자 c에 해당을한다.
이 조건절을 보면 알 수 있듯이 소문자로만 작성된 값을 얻고자 아스키 코드값을 조건절에 작성했다는 사실을 유추할 수 있다.
여기서 소문자 여부를 판단하려고 굳이 아스키 코드를 추출하는 함수까지 사용을 해야할지 고민해볼 필요가있다
*/
/*info: WHERE 절에 인덱스 절을 함수로 변형을 하면 인덱스는 타지 않게되므로 웬만하면 함수로 변형을 시켜서 안된다.*/
EXPLAIN SELECT 부서명, 비고 FROM 부서
WHERE 비고 = "active"
AND ASCII(SUBSTR(비고, 1, 1)) = 97
AND ASCII(SUBSTR(비고, 2, 1)) = 99;

/*튜닝 After*/
/*desc: 콜렉션을 조회하는 쿼리을 확인해보면 대소문자 구분없는 utf8_general_ci 콜레이션임을 확인이 가능하다. 
비고 열의 콜레이션을 기존 utf_general_ci에서 이모지까지 지원하는 UTFMB4_bin으로 변경한다.
그러면 튜닝전 substr(), ascii() 함수까지 수행하던 불필요한 작업을 제거할수있다. 
콜레이션을 변경하면 불필요한 함수를 제외한 채 비고열에 대한 조건절만 유지한다.*/
/*info: 기존 utf8_general_ci 콜레션은 데이터를 찾을 때 대소문자 구분없이 찾지만 UTFMB4_bin은 대소문자 구분이 있기에
콜레션을 변경해줌으로서 쓸데 없는 함수를 지워 인덱스를 타게할수있다.*/
SELECT COLUMN_NAME, collation_name FROM information_schema.`COLUMNS`
WHERE table_schema = 'tuning' AND TABLE_NAME = "부서"; /*콜렉션 확인해주는 쿼리*/
ALTER TABLE 부서 chane COLUMN 비고 비고 VARCHAR(40) NULL DEFAULT NULL COLLATE 'UTFMB4_bin'; /*콜레션 변경 쿼리*/
EXPLAIN SELECT 부서명, 비고 FROM 부서
WHERE 비고 = "active";

/*---------- 대소문자가 섞인 데이터와 비교하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 해당 쿼리는 이름 및 입사일자 열이있지만 풀스캔으로 데이터를 찾고있다. 
이름 열같은 경우는 LOWER 이라는 함수로 데이터를 변형했고 입사일자 같은 경우에는 사원 테이블의 30만 데이터 중 13만 데이터를
포함하고있기에 인덱스 스캔보다 풀스캔이 낫다고 옵티마이저가 판단했기 때문이다. 하지만 이름 같은 경우네느 224개의 데이터를 찾고있어 카티널리타가 높아
해당 열을 활용하면 매우 적은 범위로 데이터에 접근할 수가있다. 
하지만 우리는 업무요건에서 이름 항목에 mary, Mary, marY, maRy, MARY 등이 입력되더라도 대소문자 구분없이 Mary 라는 결과를 출력하게 만들어야한다.
그렇기 때문에 lower() 함수 값을 소문자로 변경하여 비교했다고 예상할수있는거다 그렇다면 이름 열은 왜 대소문자를 구분을하는지 확인해 필요가있다.
inofrmation_schema.colums에서 사원 테이블의 콜레이션을 조회해보니 이름열의 콜레이션이 utf8_bin이다.
해당 콜레이션은 대소문자를 구분하는 콜레이션으로 데이터정렬과 비교 시 대소문자를 구분하여 처리를한다.
하지만 최조 사용자 등록시 입력된 대소문자를 그대로 유지하려면 이름 열의 콜레이션이 utf8_bin으로 설정되어야할것이다.
그러나 이름 정보를 검색할 때는 대소문자 구분이 없어야하므로 강제적으로 lower를 사용하지만 함수를 적용한 결과 인덱스가 있어도
활용할 수가 없다고 추측할수가있다. 이때 만약 열에 대해 대소문자 구분없이 비교처리를 수행하는 별도 열이 있다면 어떨까?*/
/*info: 이름 열에 대소문자 구분없이 mary 라는 이름을 가진 사람을 찾아야한다. */
SELECT 이름, 성, 성별, 생년월일
FROM 사원
WHERE LOWER(이름) = LOWER('MARY')
AND 입사일자 >= STR_TO_DATE('1990-01-01', '%Y-%m-%d');

SELECT COUNT(*) AS cnt FROM 사원 WHERE 입사일자 >= STR_TO_DATE('1990-01-01', '%Y-%m-%d'); /*135227*/
SELECT COUNT(*) AS cnt FROM 사원 WHERE LOWER(이름) = LOWER('MARY'); /*224*/

/*튜닝 After*/
/*desc: 이름 열 옆에 소문자_이름이라는 신규 열을 추가해본다. 이 때 신규열은 별도의 콜레이션을 명시하지 않는 한 
테이블의 콜레이션 값을 상속받으므로 utf8_general_ci로 설정될것이다. 그리고 utf8_general_ci는 대소문자를 구분하지 않을것이다.
신규열을 생성하면 기존 이름 열의 데이터를 소문자 형태로 변경하여 소문자_이름 열 값으로 업데이트 한다.
물론 소문자_이름 열은 대소문자를 구분하지 않는 열이므로 LOWER() 함수를 사용할 필요가 없다.
이름 열에는 대소문자가 구분된 정확한 사원의 이름이 저장되고, 소문자 이름 열에는 대소문자 구분없이 이름을 검색할 때 활용할 데이터가 저장된다.
똑같은 이름 데이터가 증복이되므로 메모리 낭비라고 볼수있겠지만 인덱스를 활용하여 변별력이 좋은 열을 적절하게 사용하는 쿼리 튜닝 방법이다.*/
/*info: 사용자가 이름을 등록할 때 그대로 저장되기 위해서는 콜레이션을 바꾸지 않고 utf8_general_ci 콜레션을 설정한 새로운 열을 만든다 즉 검색용도인 열을 만드는것이다.*/
ALTER TABLE 사원 ADD COLUMN 소문자_이름 VARCHAR(14) NOT NULL AFTER 이름;
UPDATE 사원 SET 소문자_이름 = LOWER(이름);
ALTER TABLE 사원 ADD INDEX I_소문자이름(소문자_이름); /*이름 정보를 비교하는 로직이 업무상 자주 호출된다는 가정하에 새로 생성한 소문자 이름열로 I_소문자이름 인덱스를 다음과 같이 생성한다.*/
SELECT 이름, 성, 성별, 생년월일 FROM 사원
WHERE 소문자_이름 = 'MARY'
AND 입사일자 >= '1990-01-01';

/*---------- 분산없이 큰 규모의 데이터를 사용하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 해당 쿼리는 급여 테이블의 I_사용여부 인덱스를 활용해서 커버링 인덱슥를 수행한다.
테이블 접근없이 인덱스만으로 원하는 데이터를 조회한다. 급여 테이블에는 총 2844047건의 데이터가 있다.
2000년도의 데이터는 255785건으로 전테 급여 데이터의 약 9% 수준임을 산출 할 수 있다.
이렇게 뽑아내야하는 데이터가 많으면 인덱스를 이용한다해도 인덱스 또한 Btree구조로 계속 깊어지므로 최대의 효율을 못낸다.*/
EXPLAIN SELECT COUNT(*) AS cnt FROM 급여
WHERE 시작일자 BETWEEN STR_TO_DATE('2000-01-01', '%Y-%m-%d')
AND STR_TO_DATE('2000-12-31', '%Y-%m-%d');

/*튜닝 After*/
/*desc: 이렇게 하나의 테이블로 구성된 급여 테이블을 시작일자라는 열로 노리적으로 분할하는 파티셔닝을을 할 수 있다.
1985년 12월 31일 보다 작은 시작일자 데이터는 p85라는 파티션에 적재되고, 1986년 12월 31일 보다 작은 시작일자 데이터는 p86 파티션에적재되는 방식이다.
SQL문에서는 시작일자가 범위 기준으로 호출되는 ::범위방식 파티션으로 설정한다.
범위파티션을 설정하면 시작일자 데이터가 2000년도인 파티션에만 접근하여 SQL문 효율을 올릴수있다.
2000년도 데이터만있는 p00 파티션엔만 접근한뒤 2000-12-31 시작일자 다음 데이터 2000년인지 확인하는 작업이 수행되므로 2001년 데이터까지 접근한다.
따라서 실행계획을 보면 partitions 항목에 p00, p01이 츨력된다. */
ALTER TABLE 급여
PARTITION BY RANGE COLUMNS (시작일자)
(
  PARTITION p85 VALUES LESS THAN ('1985-12-31'),
  PARTITION p86 VALUES LESS THAN ('1986-12-31'),
  PARTITION p87 VALUES LESS THAN ('1987-12-31'),
  PARTITION p88 VALUES LESS THAN ('1988-12-31'),
  PARTITION p89 VALUES LESS THAN ('1989-12-31'),
  PARTITION p90 VALUES LESS THAN ('1990-12-31'),
  PARTITION p91 VALUES LESS THAN ('1991-12-31'),
  PARTITION p92 VALUES LESS THAN ('1992-12-31'),
  PARTITION p93 VALUES LESS THAN ('1993-12-31'),
  PARTITION p94 VALUES LESS THAN ('1994-12-31'),
  PARTITION p95 VALUES LESS THAN ('1995-12-31'),
  PARTITION p96 VALUES LESS THAN ('1996-12-31'),
  PARTITION p97 VALUES LESS THAN ('1997-12-31'),
  PARTITION p98 VALUES LESS THAN ('1998-12-31'),
  PARTITION p99 VALUES LESS THAN ('1999-12-31'),
  PARTITION p00 VALUES LESS THAN ('2000-12-31'),
  PARTITION p01 VALUES LESS THAN ('2001-12-31'),
  PARTITION p02 VALUES LESS THAN ('2002-12-31'),
  PARTITION p03 VALUES LESS THAN (MAXVALUE)
);




