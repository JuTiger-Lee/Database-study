/*---------- 기본 키를 변형하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 해당 인덱스는 PRIMARY(사원번호)로 구성이되어있어 WHERE 절에 사원번호를 찾기에 속도가 빨라야하지만
실행계획을 보면 풀스캔을 타고있는거를 확인할 수 있다. 그 이유는 사원번호 컬럼을 사용하지만 가공해서 사용했기에 풀스캔을 탄것이다.*/
EXPLAIN SELECT * FROM 사원 WHERE SUBSTRING(사원번호, 1, 4) = 1100 AND LENGTH(사원번호) = 5;

/*튜닝 After*/
EXPLAIN SELECT * FROM 사원 WHERE 사원번호 BETWEEN 11000 AND 11009;

/*---------- 사용하지 않는 함수를 포함하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: Key 항목이 인덱스로 나타나므로 인덱스 풀스캔방식으로 수행되며 Extra 항목이 Using temporary이므로 임시 테이블을 생성한다.*/
EXPLAIN SELECT IFNULL(성별, 'NO DATA') AS 성별, COUNT(1) 건수 FROM 사원 GROUP BY IFNULL(성별, 'NO DATA');

/*튜닝 After*/
/*desc: 성별열에는 NULL값이 존재하지 않으며 성별열에는 NOT NULL로 속성이 설정된것을 알 수 있다 그러므로
IFNULL 함수 때문에 DB 내부적으로 별도의 임시 테이블을 만들어서 NULL 값 여부를 검사할 필요가없다.*/
EXPLAIN SELECT 성별, COUNT(1) 건수 FROM 사원 GROUP BY 성별;

/*---------- 형변환으로 인덱스를 활용하지 못하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 사용여부 열이 인덱스로 구성되어있고 WHERE절의 조건문으로 작성이되어있지만 인덱스 풀스캔으로 수행된다.*/
EXPLAIN SELECT COUNT(1) FROM 급여 WHERE  사용여부 = 1;

/*튜닝 After*/
/*테이블 구조를 살펴보면 사용여부 열은 문자형  char(1) 데이터 유형으로 구성되었지만 WHERE 절은 숫자유형으로 데이터에 접근했으므로
DBMS 내부의 묵시적 형변환이 발생하여 인덱스를 제대로 활용하지 못해 인덱스 풀스캔이됐다 사용여부 데이터 유형에 맞게 문자열로 찾으면 효율적으로 인덱스를 탄다.*/
/*info: WHERE 절은 안고치고 문자유형인 char(1)을 숫자유형인 int로 변경하면되지만 테이블 DDl문을 수행해야하는 부담과 데이터잠김 현상으로 동시성저하 문제가발생할 수 있다.*/
/*정리: 데이터 유형에 맞게 열을 활용해야 내부적인 형변환이 발생되지 않는다. 형변환의 영향으로 의도한 인덱스를 제대로 사용하지 못하는 경우가 발생한다.*/
EXPLAIN SELECT COUNT(1) FROM 급여 WHERE  사용여부 = '1';

/*---------- 열을 결합하여 사용하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 이거또한 성별 성으로 인덱스가 구성되었지만 인덱스 컬럼을 CONCAT 함수로 가공했기에 인덱스를 안타고 FULL SCAN을 탄다.*/
EXPLAIN SELECT * FROM 사원 WHERE CONCAT(성별, ' ', 성) = 'M Radwan';

/*튜닝 After*/
EXPLAIN SELECT * FROM 사원 WHERE 성별 = 'M' AND 성 = 'Radwan';

/*---------- 습관적으로 중복을 제거하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 해당쿼리는 DISTINCT를 수행하고자 별도의 임시 테이블(Using temporary)을 만들고있음
하지만 해당쿼리에서 수행하는 DISTINCT의 사원번호는 중복되는 데이터가 없으므로 필요한 작업이 아니다.*/
EXPLAIN SELECT DISTINCT 사원.사원번호, 이름, 성, 부서번호 FROM 사원, 부서관리자 WHERE 사원.사원번호 = 부서관리자.사원번호;

/*튜닝 After*/
/*desc: DISTINCT를 없앴지만 type, rows, 소요시간은 달라지지 않았다(적은 데이터 때문에 큰차이가없음) 
하지만 DISTINCT를 제거함으로서 임시 테이블 작업 즉 불필요한 작업은 없앴다 */
/*info: DISTINCT 키워드는 나열된 열들을 정렬한 뒤 중복된 데이터는 삭제한다. 
따라서 DISTINCT를 쿼리에 작성하는것만으로도 정렬작업이 포함됨을 인지해야한다. 
이미 정렬된 기본키나 인덱스를 활용하는 경우라면 정렬 작업의 부담은 덜 수 있다.*/
EXPLAIN SELECT 사원.사원번호, 이름, 성, 부서번호 FROM 사원, 부서관리자 WHERE 사원.사원번호 = 부서관리자.사원번호;

/*---------- 다수 쿼리를 UNION 연산자로만 합치는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 해당 쿼리에 실행계획을보면 id가 NULL인 세번째 행에서는 id가 1인행과 2인 행의 결과를 통합하여 중복을 제거하는 작업을 처리
이때 메모리에 임시 테이블을 생성한다. 만약 메모리에 상주하기 어려울만큼 id가 1인행과 2인행의 결과량이 많다면 메모리가 아닌 디스크에 임시파일을 생성하여 UNION작업을 수행한다.*/
EXPLAIN SELECT 'M' AS 성별, 사원번호 FROM 사원
WHERE 성별 = 'M' AND 성 = 'Baba'

UNION

SELECT 'F', 사원번호 FROM 사원
WHERE 성별 = 'F' AND  성 = 'Baba';

/* 튜닝 After */
/*desc: 사원번호라는 기본 키가 출력된 SQL문에서 이처럼 중복을 제거하는 과정이 필요한지 고민해야한다.
첫번째 SQL문과 두번째 SQL문의 결과 데이터가 중복되지 않으므로 중복제거 작업이 필요하지 않아 임시테이블 만들고 정렬한뒤 중복을 제거하는
UNION 연산자 대신 결괏값을 단순히 합치는 UNION ALL 연산자로 변경해서 튜닝했다. 
실행결과 id 3이었던 임시테이블 행은 없어졌으므로 불필요한 작업을없앴다.*/
EXPLAIN SELECT 'M' AS 성별, 사원번호 FROM 사원
WHERE 성별 = 'M' AND 성 = 'Baba'

UNION ALL

SELECT 'F', 사원번호 FROM 사원
WHERE 성별 = 'F' AND  성 = 'Baba';

/*---------- 인덱스 고렵없이 열을 사용하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 해당쿼리는 I_성별_성 인덱스를 활용하고 고로 I_성별_성 인덱스가 GROUP BY 절에 포함되므로 커버링 인덱스로 수행된다
Using temporary, Using filesort을 출력한다. 이말은 즉 I_성별_성 인덱스 결과를 성 열과 성별 열순으로 재정렬하고자 Using temporary를 명시한것으로 해석이 가능하다.*/
EXPLAIN SELECT 성, 성별, COUNT(1) AS '카운트'
FROM 사원
GROUP BY 성, 성별;

/*튜닝 After*/
/*desc: 그루핑을 성 + 성별 순으로 수행할 떄와 성별 + 성순으로 수행할 떄의 결과는 똑같지만 
인덱스를 최대한 활용하려면 I_성별_성 인덱스데로 성별 + 성순으로 해야 그루픙과 카운트 연산을 효율적으로 수행할 수 있다.*/
/*info: 그루핑 같은 경우에는 인덱스로 정렬된 상태에서는 그루핑이 쉽지만 정렬이 안된상태에서는 
당연히 새로운 임시 테이블을 만들어서 정렬작업을 수행 후 그루핑을 진행할수밖에없기에 Using temporary Using filesort가 일어난다.*/
EXPLAIN SELECT 성, 성별, COUNT(1) AS '카운트'
FROM 사원
GROUP BY 성별, 성;

/*---------- 엉뚱한 인덱스를 사용하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/ 
/*desc: 해당 쿼리의 튜닝계획을 살펴보면 스토리지엔진에서 사원번호를 조건으로 데이터를 가져온 뒤 
mysql 엔진에서 남은 필터조건으로 추출하여 filterd 11.11%라는 예측값을 출력한다.*/
EXPLAIN SELECT 사원번호 FROM 사원 WHERE 입사일자 LIKE '1989%' AND 사원번호 > 10000;
/*desc:
전체 데이터: 300,024
입사일자 1989 년도인 데이터 건수: 28,394
사원번호가 1000000보다 큰데이터 건수 210,024
사원번호가 1000000번을 초과한 데이터가 전체 데이터에 약 70%나 차지하는 만큼 액세스 조건이 기본키가 아닌 입사일자가 액세스조건으로 활용을 해봐야한다.
USE INDEX(I_입사일자) 실행할시 소요시간은 줄었지만 실행계획에 rows는 늘어났고 튜닝은 안되었다.*/
/*info: mariaDB에서는 힌트추가만으로 Using Where; Using index로 출력되며 커버링 인덱스로 정상 수행된다.*/
EXPLAIN SELECT 사원번호 FROM 사원 USE INDEX(I_입사일자) WHERE 입사일자 LIKE '1989%' AND 사원번호 > 10000;

/*튜닝 After*/
/*입사일자 열의 데이터유형은 당연히 date다 하지만 데이터유형이 date인 입사일자를 LIKE절로 사용하는게 맞을까?
목적은 입살지가 1989년도인 입사일자를 찾는거기 때문에 부등호 조건절이 우선하여 인덱스를 사용하므로 데이터 접근 범위를 줄일 수 있다.*/
/*info: like도 시작범위를 알아서 범위 스캔이 가능하지만 액세스 조건이 안된다 하지만 부등호 조건으로 할시 조건절이 우선하여 액세스조건으로 가능하다.
::데이터 타입을 잘 파악하여 where 절 조건을 알맞게 하는게 중요!*/
EXPLAIN SELECT 사원번호 FROM 사원 WHERE 입사일자 >= '1989-01-01' AND 입사일자 < '1990-01-01' AND 사원번호 > 10000;

/*---------- 동등조건으로 인덱스를 사용하는 나쁜 SQL문 ----------*/ 
/*튜닝 Befroe*/
/*desc: 해당쿼리는 풀스캔을 타고있다 하지만 mysql 같은 경우에 해당쿼리는 I_출입문 인덱스를 타며, 인덱스를 타게되면
소요시간 3.7초로 많인 느린편이다. */
EXPLAIN SELECT * FROM 사원출입기록 WHERE 출입문 = 'B';

/*튜닝 After*/
/*desc: 출입문 B 같은경우는 총 66만건 전체 데이터중 30만건을 차지한다 즉 50%에 달하는 데이터를 조회하는데
해당 데이터를 인덱스로 데이터를 찾는게 과연 효율적인지 고민을 해봐야한다. 그렇기에 인덱스를 타지않고 풀스캔을 탈수있게 
IGNORE INDEX를 탈수있게 힌트를 주면된다. 힌트를 준후 쿼리를 실행해보면 0.85초가걸리게된다.*/
/*index는 랜덤액세스로 타지만 풀스캔은 시퀀셜 액세스로 한번 액세스하기에 데이터 비중이 높은 케이스는 풀스캔이 유리하다
즉 인덱스를 탄다해서 무조건 빠른거는 아니다.*/
EXPLAIN SELECT * FROM 사원출입기록 IGNORE INDEX(I_출입문) WHERE 출입문 = 'B';

/*---------- 범위 조건으로 인덱스를 사용하는 나쁜 SQL문 ----------*/ 
/*튜닝 Befroe ::책과 다르게 인덱스를 안타서 강제 인덱스타게 FORCE INDEX 설정*/
/*desc: 해당쿼리는 입사일자가 1994년 1월 1일부터 2000년 12월 31일까지인 사원들의 이름과 성을 출력하는 쿼리이다.
해당쿼리는 총 48,875건이고 소요시간은 1.21초이다. I_입사일자로 BETWEEN을 사용하니깐 range(범위)스캔을 수행하며
Using index condition을 통해 스토리지엔진에서 입사일자의 조건절로 인덱스 스캔을 수행한다 또한 Using MRR을 통해 
인덱스가 랜덤이 아닌 순차적으로 스캔하여 최적화하여 처리됨을 확인할수있다.*/
EXPLAIN SELECT 이름, 성 FROM 사원 FORCE INDEX(I_입사일자) WHERE 입사일자 BETWEEN STR_TO_DATE('1994-01-01', '%Y-%m-%d') AND STR_TO_DATE('2000-12-31', '%Y-%m-%d');

/*튜닝 After*/
/*desc: 사원 테이블의 데이터는 총 300,024건이며 결과건수는 48,875건으로 약 17%를 차지한다. 
이때 인덱스를 활용할지 아니면 풀스캔을 활용할지 고민해봐야한다. 
매번 입사일자 열 기준으로 수년에 걸친 데이터를 조회하는 경우가 잦다면 인덱스 스캔으로 부하를 주는거보다는 테이블 풀 스캔방식으로 고정적으로 설정하는게 낫다.
인덱스 열을 가공하면 인덱스를 안타게된다 이러한 점을 이용하여 테이블 풀스캔을 타도록 유도하여 쿼리를 튜닝한다.
튜닝결과 소요시간은 1.21초에서 0.2초로 줄어들었다.*/
EXPLAIN SELECT 이름, 성 FROM 사원 WHERE YEAR(입사일자) BETWEEN '1994' AND '2000';

/*---------- 작은 테이블이 먼저 조인에 참여하는 나쁜 SQL문 ----------*/ 
/*튜닝 Befroe*/
/*desc: 해당쿼리는 13.2초의 시간이 소요되는 쿼리이며 
드라이빙 테이블인 부서 테이블과 드리븐 테이블인 부서사원_매핑 테이블을 중첩루프조인을 수행한다. 
큰 크기의 부서사원_매핑 테이블은 I_부서번호 인덱스로 인덱스 스캔을 수행한다. 이때 rows 항목의 41392라는 수치는 예측건수이며
인덱스 스캔을 하고 랜덤 액세스로 테이블에 접근하된다. 이처럼 드리븐 테이블에서 대량의 데이터에 대해 랜덤액세스는 비효율적이다.
또한 부서사원_매핑 테이블에는 30만건 이상의 데이터가 있으나 mysql 엔진으로 가져온 모든 데이터에 대해 WHERE 절의 필터 조근을 수행한다.
::드라이빙 테이블인 부서테이블은 9건의 데이터가 드리븐 테이블인 부서사원_매핑 테이블에는 약 33만건의 데이터가 있다.
드리븐 테이블에는 조건절로 추출한 부서사원_매핑 테이블의 데이터 건수는 약 1341건이다. 이 건수는 전체 데이터에 0.4%수준에 불과하다.
규모가 큰 부서사원_매핑 테이블의 조건절을 먼저 적용할수있다면 조인할 때 비교대상이 줄어들것이다.*/
/*info:부서사원_매핑 테이블에 대해 시작일자 열이 범위 조건으로 작성되는지 
범위에 해당하는 데이터가 5% 이하(명확한 기준은 없음 10% 혹은 1%)에 불과한 소량의 데이터를 조회하는지 함께 분석이 필요하다.
부서사원_매핑 테이블에 시작일자 열 기준으로 인덱스를 생성하면 인덱스를 통해 더 효율적으로 인덱스 스캔이 가능하다.*/
EXPLAIN SELECT 매핑.사원번호, 부서.`부서번호` FROM 부서사원_매핑 매핑, 부서
WHERE 매핑.`부서번호` = 부서.`부서번호`
AND 매핑.`시작일자` >= '2002-03-01';
/*1341*/
SELECT COUNT(*) AS cnt FROM 부서사원_매핑 매핑 WHERE 매핑.`시작일자` >= '2002-03-01';
/*30만*/
SELECT COUNT(*) AS cnt FROM 부서사원_매핑 매핑;

/*튜닝 After*/
/*desc: 드라이빙 테이블에서의 조인 비교 건수를 줄이도록(매핑 시작일자 조건절을 먼저 수행하도록) STRAIGHT_JOIN 힌트를 사용하여 
FROM절에 작성된 테이블 순서대로 조인에 참여할 수 있도록 고정해야한다.
즉 부서사원_매핑 테이블에 먼저 접근하고 이후 부서 테이블에 반복하여 접근하면서 최종결과를 추출한다.*/
/*info: 옵티마이저에서는 자동적으로 rows가 적은 부서 테이블을 드라이빙 테이블을 두고 부서사원_매핑 테이블을 드리븐 테이블로둔다(FROM순서와 상관없이)
하지만 드리븐 테이블에 rows가 많으면 랜덤액세스가 그만큼 많이 일어나기에 비효율적이므로 rows가 더 많아도 효율적으로 할 수 있게 FROM절 순서처럼 쿼리를 실행할 수 있게
STRAIGHT_JOIN 힌트를 사용하여 드리븐 테이블에 랜덤액세스를 줄일수있게한다.
즉 9건의 부서 테이블이 30만건 테이블 즉 1건마다 30만건 총 270만건을 join하는거보다는
1341건의 부서사원_매핑 테이블이 9건에 부서테이블을 조인하는게 랜덤액세스에 더 효율적이라는거다. 왜냐하면 부서번호는 인덱스로 구성되었기에 액세스가 1341 밖에 안일어난다.*/
EXPLAIN SELECT STRAIGHT_JOIN 매핑.사원번호, 부서.`부서번호` FROM 부서사원_매핑 매핑, 부서
WHERE 매핑.`부서번호` = 부서.`부서번호`
AND 매핑.`시작일자` >= '2002-03-01';

/*---------- 메인 테이블에 계속 의존하는 나쁜 SQL문 ----------*/ 
/*튜닝 Befroe*/
/*desc: 해당 쿼리는 서원번호가 450,000번을 초과하면서 그동안 받은 연봉 중 한번이라도 100,000달러들 초과한적이있는 사원을 출력하는 쿼리이다.
외부의 사원테이블로부터 조건절을 전달받아 수행해야하는 의존성을 가진 쿼리(select_type: DEPENDENT SUBQUERY)는 튜닝 대상으로 고려할 수 있다.
그 이유는 WHERE 절이 실행될 때 마다 급여 서브쿼리가 돌기에 성능상 좋지 않는다. 서브쿼리를 대신해서 조인으로 변경하는 방향으로 생각해보는거를 고려해야한다.
info: 튜닝 책의 필자 경험상 서브쿼리보다는 조인으로 수행하는 편이 성능 측면에서 유리할 가능성이 높다 ::특히 의존성쿼리는*/
EXPLAIN SELECT 사원.`사원번호`, 사원.`이름`, 사원.`성`
FROM 사원
WHERE 사원번호 > 450000
AND(SELECT MAX(연봉) FROM 급여 WHERE 사원번호 = 사원.`사원번호`) > 100000;

/*튜닝 After*/
/*desc: WHERE 절의 서브쿼리를 조인으로 변경하면서 GROUP BY 절과 HAVING 절을 이용하여 튜닝 전의 그룹별 최댓값을 계산하도록 개선했다.
즉 GROUP BY 절에서는 사원번호별 그루핑을 수행하고 HAVING 절에서는 연봉의 최댓값으로 조건을 설정하여 원하는 데이터를 조회한다.
여기서 드라이빙 테이블이 급여 테이블 드리븐 테이블은 사원 테이블이다 또한 급여 테이블에서 먼저 접근하기 위한 범위 축소 조건은
WHERE 사원.사원번호 > 450000 절을 통한 급여.사원번호 > 450000 조건절로 변형되어 적용 이는 옵티마이저에 의해 SQL문이 재작성된 부분으로 수행한다.
튜닝전에 급여테이블의 DEPENDENT SUBQUERY 방식은 제거되고 조인하는 방식으로 변경되어 수행효율이 향상됨을 확인할수있다.*/
/*info 실행계획의 rows 항목정보는 SQL수행을 위해 조사하는 행 수의 예측 값이므로 단순하게 rows 수치의 많고 적음으로 튜닝 성공 여부를 판단하기는 어렵다.*/
EXPLAIN SELECT 사원.`사원번호`, 사원.`이름`, 사원.`성`
FROM 사원, 급여
WHERE 사원.`사원번호` > 450000
AND 사원.`사원번호` = 급여.`사원번호`
GROUP BY 사원.`사원번호`
HAVING MAX(급여.`연봉`) > 100000;

/*---------- 불필요한 조인을 수행하는 나쁜 SQL문 ----------*/ 
/*튜닝 Before*/
/*desc: 실행계획을 보면 사원출입기록 테이블과 사원 테이블 둘다 id가 1이므로 조인을 수행했다는거를 알 수 있다.
즉 FROM 절의 인라인뷰는 사실상 옵티마이저에 의해 조인 방식이 뷰병합으,로 최적화 되어 조인처럼 수행이되는것이다.
이 때 실제로 66만여건에 달하는 사원출입기록 테이블의 데이터 결과가 최종결과에 어떻게 활용되는지 확인이 필요하다
왜냐하면 사원출입기록 테이블의 사원번호는 사원테이블과 조인을 수행하는 과정 중에 값의 존재여부만 알면되기 때문이다.(증복제거를 할 필요가없다는 뜻)*/
EXPLAIN SELECT COUNT(DISTINCT 사원.`사원번호`) AS 데이터건수 
FROM 사원,(
	SELECT 사원번호 FROM 사원출입기록 기록 WHERE 출입문 = 'A'
	) 기록
WHERE 사원.`사원번호` = 기록.사원번호;

/*튜닝 After*/
/*desc: 사원출입기록 테이블의 데이터느 최종결과에 사용하지 않고 단지 존재여부만 파악하면 되므로 EXISTS 구문으로 변경한다.
출입문 A에 관한 기록이있는 사원번호에 대해 조인을 수행한뒤 해당하는 데이터만 집계하는 방식으로 튜닝을한다.*/
/*info: 실행계획을 보면 id가 1인 table 항목에 먼저 출력된 사원 테이블은 드라이빙 테이블이고 
다음으로 출력된 <subquery2>는 드리븐 테이블이다. 여기서 드리븐 테이블의 id가 2인 사원출력기록 테이블로서
사원출력기록 테이블은 EXISTS 연산자로 데이터 존재여부를 파악하기 위해 임시테이블을 생성하는 MATERIALIZED 로 표기된다.*/
EXPLAIN SELECT COUNT(1) AS 데이터건수 
FROM 사원
WHERE EXISTS(
 SELECT 1 FROM 사원출입기록 기록 WHERE 출입문 = 'A'
 AND 기록.사원번호 = 사원.`사원번호`);
